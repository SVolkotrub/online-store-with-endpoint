{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n} // Bundled with Packemon: https://packemon.dev\n// Platform: browser, Support: stable, Format: esm\n\n\nimport { F as Filter, A as ALLOWED_TAG_LIST, B as BANNED_TAG_LIST, a as ATTRIBUTES, b as FILTER_DENY, c as ATTRIBUTES_TO_PROPS, T as TAGS, E as Element, d as FILTER_CAST_BOOL, e as FILTER_CAST_NUMBER, f as FILTER_NO_CAST } from './bundle-94421b73.js';\nexport { A as ALLOWED_TAG_LIST, a as ATTRIBUTES, c as ATTRIBUTES_TO_PROPS, B as BANNED_TAG_LIST, E as Element, n as FILTER_ALLOW, d as FILTER_CAST_BOOL, e as FILTER_CAST_NUMBER, b as FILTER_DENY, f as FILTER_NO_CAST, F as Filter, M as Matcher, T as TAGS, k as TYPE_EMBEDDED, g as TYPE_FLOW, i as TYPE_HEADING, l as TYPE_INTERACTIVE, m as TYPE_PALPABLE, j as TYPE_PHRASING, h as TYPE_SECTION, o as match } from './bundle-94421b73.js';\nimport React from 'react';\nimport escapeHtml from 'escape-html';\nconst INVALID_STYLES = /(url|image|image-set)\\(/i;\n\nclass StyleFilter extends Filter {\n  attribute(name, value) {\n    if (name === 'style') {\n      Object.keys(value).forEach(key => {\n        if (String(value[key]).match(INVALID_STYLES)) {\n          // eslint-disable-next-line no-param-reassign\n          delete value[key];\n        }\n      });\n    } // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n\n\n    return value;\n  }\n\n}\n/* eslint-disable no-bitwise, no-cond-assign, complexity, @typescript-eslint/no-unsafe-return */\n\n\nconst ELEMENT_NODE = 1;\nconst TEXT_NODE = 3;\nconst INVALID_ROOTS = /^<(!doctype|(html|head|body)(\\s|>))/i;\nconst ALLOWED_ATTRS = /^(aria-|data-|\\w+:)/iu;\nconst OPEN_TOKEN = /{{{(\\w+)\\/?}}}/;\n\nfunction createDocument() {\n  // Maybe SSR? Just do nothing instead of crashing!\n  if (typeof window === 'undefined' || typeof document === 'undefined') {\n    return undefined;\n  }\n\n  return document.implementation.createHTMLDocument('Interweave');\n}\n\nclass Parser {\n  constructor(markup) {\n    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let matchers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    let filters = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n\n    var _props$allowList;\n\n    _defineProperty(this, \"allowed\", void 0);\n\n    _defineProperty(this, \"banned\", void 0);\n\n    _defineProperty(this, \"blocked\", void 0);\n\n    _defineProperty(this, \"container\", void 0);\n\n    _defineProperty(this, \"content\", []);\n\n    _defineProperty(this, \"props\", void 0);\n\n    _defineProperty(this, \"matchers\", void 0);\n\n    _defineProperty(this, \"filters\", void 0);\n\n    _defineProperty(this, \"keyIndex\", void 0);\n\n    if (process.env.NODE_ENV !== \"production\" && markup && typeof markup !== 'string') {\n      throw new TypeError('Interweave parser requires a valid string.');\n    }\n\n    this.props = props;\n    this.matchers = matchers;\n    this.filters = [...filters, new StyleFilter()];\n    this.keyIndex = -1;\n    this.container = this.createContainer(markup || '');\n    this.allowed = new Set((_props$allowList = props.allowList) !== null && _props$allowList !== void 0 ? _props$allowList : ALLOWED_TAG_LIST);\n    this.banned = new Set(BANNED_TAG_LIST);\n    this.blocked = new Set(props.blockList);\n  }\n  /**\r\n   * Loop through and apply all registered attribute filters.\r\n   */\n\n\n  applyAttributeFilters(name, value) {\n    return this.filters.reduce((nextValue, filter) => nextValue !== null && typeof filter.attribute === 'function' ? filter.attribute(name, nextValue) : nextValue, value);\n  }\n  /**\r\n   * Loop through and apply all registered node filters.\r\n   */\n\n\n  applyNodeFilters(name, node) {\n    // Allow null to be returned\n    return this.filters.reduce((nextNode, filter) => nextNode !== null && typeof filter.node === 'function' ? filter.node(name, nextNode) : nextNode, node);\n  }\n  /**\r\n   * Loop through and apply all registered matchers to the string.\r\n   * If a match is found, create a React element, and build a new array.\r\n   * This array allows React to interpolate and render accordingly.\r\n   */\n\n\n  applyMatchers(string, parentConfig) {\n    const elements = {};\n    const {\n      props\n    } = this;\n    let matchedString = string;\n    let elementIndex = 0;\n    let parts = null;\n    this.matchers.forEach(matcher => {\n      const tagName = matcher.asTag().toLowerCase();\n      const config = this.getTagConfig(tagName); // Skip matchers that have been disabled from props or are not supported\n\n      if (props[matcher.inverseName] || !this.isTagAllowed(tagName)) {\n        return;\n      } // Skip matchers in which the child cannot be rendered\n\n\n      if (!this.canRenderChild(parentConfig, config)) {\n        return;\n      } // Continuously trigger the matcher until no matches are found\n\n\n      let tokenizedString = '';\n\n      while (matchedString && (parts = matcher.match(matchedString))) {\n        const {\n          index,\n          length,\n          match,\n          valid,\n          void: isVoid,\n          ...partProps\n        } = parts;\n        const tokenName = matcher.propName + String(elementIndex); // Piece together a new string with interpolated tokens\n\n        if (index > 0) {\n          tokenizedString += matchedString.slice(0, index);\n        }\n\n        if (valid) {\n          tokenizedString += isVoid ? `{{{${tokenName}/}}}` : `{{{${tokenName}}}}${match}{{{/${tokenName}}}}`;\n          this.keyIndex += 1;\n          elementIndex += 1;\n          elements[tokenName] = {\n            children: match,\n            matcher,\n            props: { ...props,\n              ...partProps,\n              key: this.keyIndex\n            }\n          };\n        } else {\n          tokenizedString += match;\n        } // Reduce the string being matched against,\n        // otherwise we end up in an infinite loop!\n\n\n        if (matcher.greedy) {\n          matchedString = tokenizedString + matchedString.slice(index + length);\n          tokenizedString = '';\n        } else {\n          // eslint-disable-next-line unicorn/explicit-length-check\n          matchedString = matchedString.slice(index + (length || match.length));\n        }\n      } // Update the matched string with the tokenized string,\n      // so that the next matcher can apply to it.\n\n\n      if (!matcher.greedy) {\n        matchedString = tokenizedString + matchedString;\n      }\n    });\n\n    if (elementIndex === 0) {\n      return string;\n    }\n\n    return this.replaceTokens(matchedString, elements);\n  }\n  /**\r\n   * Determine whether the child can be rendered within the parent.\r\n   */\n\n\n  canRenderChild(parentConfig, childConfig) {\n    if (!parentConfig.tagName || !childConfig.tagName) {\n      return false;\n    } // No children\n\n\n    if (parentConfig.void) {\n      return false;\n    } // Valid children\n\n\n    if (parentConfig.children.length > 0) {\n      return parentConfig.children.includes(childConfig.tagName);\n    }\n\n    if (parentConfig.invalid.length > 0 && parentConfig.invalid.includes(childConfig.tagName)) {\n      return false;\n    } // Valid parent\n\n\n    if (childConfig.parent.length > 0) {\n      return childConfig.parent.includes(parentConfig.tagName);\n    } // Self nesting\n\n\n    if (!parentConfig.self && parentConfig.tagName === childConfig.tagName) {\n      return false;\n    } // Content category type\n\n\n    return Boolean(parentConfig && parentConfig.content & childConfig.type);\n  }\n  /**\r\n   * Convert line breaks in a string to HTML `<br/>` tags.\r\n   * If the string contains HTML, we should not convert anything,\r\n   * as line breaks should be handled by `<br/>`s in the markup itself.\r\n   */\n\n\n  convertLineBreaks(markup) {\n    const {\n      noHtml,\n      disableLineBreaks\n    } = this.props;\n\n    if (noHtml || disableLineBreaks || markup.match(/<((?:\\/[ a-z]+)|(?:[ a-z]+\\/))>/gi)) {\n      return markup;\n    } // Replace carriage returns\n\n\n    let nextMarkup = markup.replace(/\\r\\n/g, '\\n'); // Replace long line feeds\n\n    nextMarkup = nextMarkup.replace(/\\n{3,}/g, '\\n\\n\\n'); // Replace line feeds with `<br/>`s\n\n    nextMarkup = nextMarkup.replace(/\\n/g, '<br/>');\n    return nextMarkup;\n  }\n  /**\r\n   * Create a detached HTML document that allows for easy HTML\r\n   * parsing while not triggering scripts or loading external\r\n   * resources.\r\n   */\n\n\n  createContainer(markup) {\n    var _this$props$container;\n\n    const factory = typeof global !== 'undefined' && global.INTERWEAVE_SSR_POLYFILL || createDocument;\n    const doc = factory();\n\n    if (!doc) {\n      return undefined;\n    }\n\n    const tag = (_this$props$container = this.props.containerTagName) !== null && _this$props$container !== void 0 ? _this$props$container : 'body';\n    const el = tag === 'body' || tag === 'fragment' ? doc.body : doc.createElement(tag);\n\n    if (markup.match(INVALID_ROOTS)) {\n      if (process.env.NODE_ENV !== \"production\") {\n        throw new Error('HTML documents as Interweave content are not supported.');\n      }\n    } else {\n      el.innerHTML = this.convertLineBreaks(this.props.escapeHtml ? escapeHtml(markup) : markup);\n    }\n\n    return el;\n  }\n  /**\r\n   * Convert an elements attribute map to an object map.\r\n   * Returns null if no attributes are defined.\r\n   */\n\n\n  extractAttributes(node) {\n    const {\n      allowAttributes\n    } = this.props;\n    const attributes = {};\n    let count = 0;\n\n    if (node.nodeType !== ELEMENT_NODE || !node.attributes) {\n      return null;\n    } // @ts-expect-error Cant type iterator\n\n\n    [...node.attributes].forEach(attr => {\n      const {\n        name,\n        value\n      } = attr;\n      const newName = name.toLowerCase();\n      const filter = ATTRIBUTES[newName] || ATTRIBUTES[name]; // Verify the node is safe from attacks\n\n      if (!this.isSafe(node)) {\n        return;\n      } // Do not allow denied attributes, excluding ARIA attributes\n      // Do not allow events or XSS injections\n\n\n      if (!newName.match(ALLOWED_ATTRS) && (!allowAttributes && (!filter || filter === FILTER_DENY) || newName.startsWith('on') || value.replace(/(\\s|\\0|&#x0([9AD]);)/, '').match(/(javascript|vbscript|livescript|xss):/i))) {\n        return;\n      } // Apply attribute filters\n\n\n      let newValue = newName === 'style' ? this.extractStyleAttribute(node) : value; // Cast to boolean\n\n      if (filter === FILTER_CAST_BOOL) {\n        newValue = true; // Cast to number\n      } else if (filter === FILTER_CAST_NUMBER) {\n        newValue = Number.parseFloat(String(newValue)); // Cast to string\n      } else if (filter !== FILTER_NO_CAST) {\n        newValue = String(newValue);\n      }\n\n      attributes[ATTRIBUTES_TO_PROPS[newName] || newName] = this.applyAttributeFilters(newName, newValue);\n      count += 1;\n    });\n\n    if (count === 0) {\n      return null;\n    }\n\n    return attributes;\n  }\n  /**\r\n   * Extract the style attribute as an object and remove values that allow for attack vectors.\r\n   */\n\n\n  extractStyleAttribute(node) {\n    const styles = {}; // eslint-disable-next-line unicorn/prefer-spread\n\n    Array.from(node.style).forEach(key => {\n      const value = node.style[key];\n\n      if (typeof value === 'string' || typeof value === 'number') {\n        styles[key.replace(/-([a-z])/g, (match, letter) => String(letter).toUpperCase())] = value;\n      }\n    });\n    return styles;\n  }\n  /**\r\n   * Return configuration for a specific tag.\r\n   */\n\n\n  getTagConfig(tagName) {\n    const common = {\n      children: [],\n      content: 0,\n      invalid: [],\n      parent: [],\n      self: true,\n      tagName: '',\n      type: 0,\n      void: false\n    }; // Only spread when a tag config exists,\n    // otherwise we use the empty `tagName`\n    // for parent config inheritance.\n\n    if (TAGS[tagName]) {\n      return { ...common,\n        ...TAGS[tagName],\n        tagName\n      };\n    }\n\n    return common;\n  }\n  /**\r\n   * Verify that a node is safe from XSS and injection attacks.\r\n   */\n\n\n  isSafe(node) {\n    // URLs should only support HTTP, email and phone numbers\n    if (typeof HTMLAnchorElement !== 'undefined' && node instanceof HTMLAnchorElement) {\n      const href = node.getAttribute('href'); // Fragment protocols start with about:\n      // So let's just allow them\n\n      if (href !== null && href !== void 0 && href.startsWith('#')) {\n        return true;\n      }\n\n      const protocol = node.protocol.toLowerCase();\n      return protocol === ':' || protocol === 'http:' || protocol === 'https:' || protocol === 'mailto:' || protocol === 'tel:';\n    }\n\n    return true;\n  }\n  /**\r\n   * Verify that an HTML tag is allowed to render.\r\n   */\n\n\n  isTagAllowed(tagName) {\n    if (this.banned.has(tagName) || this.blocked.has(tagName)) {\n      return false;\n    } // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n\n\n    return this.props.allowElements || this.allowed.has(tagName);\n  }\n  /**\r\n   * Parse the markup by injecting it into a detached document,\r\n   * while looping over all child nodes and generating an\r\n   * array to interpolate into JSX.\r\n   */\n\n\n  parse() {\n    if (!this.container) {\n      return [];\n    }\n\n    return this.parseNode(this.container, this.getTagConfig(this.container.nodeName.toLowerCase()));\n  }\n  /**\r\n   * Loop over the nodes children and generate a\r\n   * list of text nodes and React elements.\r\n   */\n\n\n  parseNode(parentNode, parentConfig) {\n    const {\n      noHtml,\n      noHtmlExceptMatchers,\n      allowElements,\n      transform,\n      transformOnlyAllowList\n    } = this.props;\n    let content = [];\n    let mergedText = ''; // @ts-expect-error Cant type iterator\n\n    [...parentNode.childNodes].forEach(node => {\n      // Create React elements from HTML elements\n      if (node.nodeType === ELEMENT_NODE) {\n        const tagName = node.nodeName.toLowerCase();\n        const config = this.getTagConfig(tagName); // Persist any previous text\n\n        if (mergedText) {\n          content.push(mergedText);\n          mergedText = '';\n        } // Apply node filters first\n\n\n        const nextNode = this.applyNodeFilters(tagName, node);\n\n        if (!nextNode) {\n          return;\n        } // Apply transformation second\n\n\n        let children;\n\n        if (transform && !(transformOnlyAllowList && !this.isTagAllowed(tagName))) {\n          this.keyIndex += 1;\n          const key = this.keyIndex; // Must occur after key is set\n\n          children = this.parseNode(nextNode, config);\n          const transformed = transform(nextNode, children, config);\n\n          if (transformed === null) {\n            return;\n          }\n\n          if (typeof transformed !== 'undefined') {\n            content.push( /*#__PURE__*/React.cloneElement(transformed, {\n              key\n            }));\n            return;\n          } // Reset as we're not using the transformation\n\n\n          this.keyIndex = key - 1;\n        } // Never allow these tags (except via a transformer)\n\n\n        if (this.banned.has(tagName)) {\n          return;\n        } // Only render when the following criteria is met:\n        //  - HTML has not been disabled\n        //  - Tag is allowed\n        //  - Child is valid within the parent\n\n\n        if (!(noHtml || noHtmlExceptMatchers && tagName !== 'br') && this.isTagAllowed(tagName) && (allowElements || this.canRenderChild(parentConfig, config))) {\n          var _children;\n\n          this.keyIndex += 1; // Build the props as it makes it easier to test\n\n          const attributes = this.extractAttributes(nextNode);\n          const elementProps = {\n            tagName\n          };\n\n          if (attributes) {\n            elementProps.attributes = attributes;\n          }\n\n          if (config.void) {\n            elementProps.selfClose = config.void;\n          }\n\n          content.push( /*#__PURE__*/React.createElement(Element, { ...elementProps,\n            key: this.keyIndex\n          }, (_children = children) !== null && _children !== void 0 ? _children : this.parseNode(nextNode, config))); // Render the children of the current element only.\n          // Important: If the current element is not allowed,\n          // use the parent element for the next scope.\n        } else {\n          content = [...content, ...this.parseNode(nextNode, config.tagName ? config : parentConfig)];\n        } // Apply matchers if a text node\n\n      } else if (node.nodeType === TEXT_NODE) {\n        const text = noHtml && !noHtmlExceptMatchers ? node.textContent : // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        this.applyMatchers(node.textContent || '', parentConfig);\n\n        if (Array.isArray(text)) {\n          content = [...content, ...text];\n        } else {\n          mergedText += text;\n        }\n      }\n    });\n\n    if (mergedText) {\n      content.push(mergedText);\n    }\n\n    return content;\n  }\n  /**\r\n   * Deconstruct the string into an array, by replacing custom tokens with React elements,\r\n   * so that React can render it correctly.\r\n   */\n\n\n  replaceTokens(tokenizedString, elements) {\n    if (!tokenizedString.includes('{{{')) {\n      return tokenizedString;\n    }\n\n    const nodes = [];\n    let text = tokenizedString;\n    let open = null; // Find an open token tag\n\n    while (open = text.match(OPEN_TOKEN)) {\n      const [match, tokenName] = open;\n      const startIndex = open.index;\n      const isVoid = match.includes('/');\n\n      if (process.env.NODE_ENV !== \"production\" && !elements[tokenName]) {\n        throw new Error(`Token \"${tokenName}\" found but no matching element to replace with.`);\n      } // Extract the previous non-token text\n\n\n      if (startIndex > 0) {\n        nodes.push(text.slice(0, startIndex)); // Reduce text so that the closing tag will be found after the opening\n\n        text = text.slice(startIndex);\n      }\n\n      const {\n        children,\n        matcher,\n        props: elementProps\n      } = elements[tokenName];\n      let endIndex; // Use tag as-is if void\n\n      if (isVoid) {\n        endIndex = match.length;\n        nodes.push(matcher.createElement(children, elementProps)); // Find the closing tag if not void\n      } else {\n        const close = text.match(new RegExp(`{{{/${tokenName}}}}`));\n\n        if (process.env.NODE_ENV !== \"production\" && !close) {\n          throw new Error(`Closing token missing for interpolated element \"${tokenName}\".`);\n        }\n\n        endIndex = close.index + close[0].length;\n        nodes.push(matcher.createElement(this.replaceTokens(text.slice(match.length, close.index), elements), elementProps));\n      } // Reduce text for the next interation\n\n\n      text = text.slice(endIndex);\n    } // Extra the remaining text\n\n\n    if (text.length > 0) {\n      nodes.push(text);\n    } // Reduce to a string if possible\n\n\n    if (nodes.length === 0) {\n      return '';\n    }\n\n    if (nodes.length === 1 && typeof nodes[0] === 'string') {\n      return nodes[0];\n    }\n\n    return nodes;\n  }\n\n}\n/* eslint-disable react/jsx-fragments */\n\n\nfunction Markup(props) {\n  var _ref;\n\n  const {\n    attributes,\n    className,\n    containerTagName,\n    content,\n    emptyContent,\n    parsedContent,\n    tagName,\n    noWrap: baseNoWrap\n  } = props;\n  const tag = (_ref = containerTagName !== null && containerTagName !== void 0 ? containerTagName : tagName) !== null && _ref !== void 0 ? _ref : 'span';\n  const noWrap = tag === 'fragment' ? true : baseNoWrap;\n  let mainContent;\n\n  if (parsedContent) {\n    mainContent = parsedContent;\n  } else {\n    const markup = new Parser(content !== null && content !== void 0 ? content : '', props).parse();\n\n    if (markup.length > 0) {\n      mainContent = markup;\n    }\n  }\n\n  if (!mainContent) {\n    mainContent = emptyContent;\n  }\n\n  if (noWrap) {\n    // eslint-disable-next-line react/jsx-no-useless-fragment\n    return /*#__PURE__*/React.createElement(React.Fragment, null, mainContent);\n  }\n\n  return /*#__PURE__*/React.createElement(Element, {\n    attributes: attributes,\n    className: className,\n    tagName: tag\n  }, mainContent);\n}\n/* eslint-disable promise/prefer-await-to-callbacks */\n\n\nfunction Interweave(props) {\n  const {\n    attributes,\n    className,\n    content = '',\n    disableFilters = false,\n    disableMatchers = false,\n    emptyContent = null,\n    filters = [],\n    matchers = [],\n    onAfterParse = null,\n    onBeforeParse = null,\n    tagName = 'span',\n    noWrap = false,\n    ...parserProps\n  } = props;\n  const allMatchers = disableMatchers ? [] : matchers;\n  const allFilters = disableFilters ? [] : filters;\n  const beforeCallbacks = onBeforeParse ? [onBeforeParse] : [];\n  const afterCallbacks = onAfterParse ? [onAfterParse] : []; // Inherit callbacks from matchers\n\n  allMatchers.forEach(matcher => {\n    if (matcher.onBeforeParse) {\n      beforeCallbacks.push(matcher.onBeforeParse.bind(matcher));\n    }\n\n    if (matcher.onAfterParse) {\n      afterCallbacks.push(matcher.onAfterParse.bind(matcher));\n    }\n  }); // Trigger before callbacks\n\n  const markup = beforeCallbacks.reduce((string, callback) => {\n    const nextString = callback(string, props);\n\n    if (process.env.NODE_ENV !== \"production\" && typeof nextString !== 'string') {\n      throw new TypeError('Interweave `onBeforeParse` must return a valid HTML string.');\n    }\n\n    return nextString;\n  }, content !== null && content !== void 0 ? content : ''); // Parse the markup\n\n  const parser = new Parser(markup, parserProps, allMatchers, allFilters); // Trigger after callbacks\n\n  const nodes = afterCallbacks.reduce((parserNodes, callback) => {\n    const nextNodes = callback(parserNodes, props);\n\n    if (process.env.NODE_ENV !== \"production\" && !Array.isArray(nextNodes)) {\n      throw new TypeError('Interweave `onAfterParse` must return an array of strings and React elements.');\n    }\n\n    return nextNodes;\n  }, parser.parse());\n  return /*#__PURE__*/React.createElement(Markup, {\n    attributes: attributes,\n    className: className // eslint-disable-next-line react/destructuring-assignment\n    ,\n    containerTagName: props.containerTagName,\n    emptyContent: emptyContent,\n    noWrap: noWrap,\n    parsedContent: nodes.length === 0 ? undefined : nodes,\n    tagName: tagName\n  });\n}\n\nexport { Interweave, Markup, Parser };","map":{"version":3,"mappings":"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","names":["StyleFilter","Filter","attribute","name","value","Object","keys","forEach","key","String","match","INVALID_STYLES","TEXT_NODE","INVALID_ROOTS","ALLOWED_ATTRS","OPEN_TOKEN","undefined","allowed","banned","blocked","content","matchers","keyIndex","constructor","markup","props","_defineProperty","TypeError","allowList","env","NODE_ENV","blockList","applyAttributeFilters","filters","reduce","filter","applyNodeFilters","applyMatchers","string","parentConfig","matcher","canRenderChild","config","valid","void","index","tokenizedString","elementIndex","elements","children","partProps","matchedString","greedy","length","childConfig","noHtml","disableLineBreaks","convertLineBreaks","replace","nextMarkup","factory","global","doc","createContainer","extractAttributes","allowAttributes","count","attr","node","newName","newValue","ATTRIBUTES","extractStyleAttribute","isSafe","FILTER_CAST_BOOL","attributes","Array","from","styles","getTagConfig","tagName","invalid","parent","self","type","TAGS","common","href","isTagAllowed","parse","parseNode","container","noHtmlExceptMatchers","transform","transformOnlyAllowList","ELEMENT_NODE","allowElements","mergedText","elementProps","replaceTokens","open","nodes","push","text","slice","tokenName","endIndex","Error","isVoid","className","emptyContent","parsedContent","noWrap","mainContent","_ref","containerTagName","disableFilters","disableMatchers","React","onAfterParse","Element","onBeforeParse","tag","afterCallbacks","allMatchers","beforeCallbacks","nextString","parser","isArray","nextNodes","bind"],"sources":["H:\\Svetik\\qa-testing\\online-store-with-endpoint\\online-store\\node_modules\\interweave\\src\\StyleFilter.ts","H:\\Svetik\\qa-testing\\online-store-with-endpoint\\online-store\\node_modules\\interweave\\src\\Parser.ts","H:\\Svetik\\qa-testing\\online-store-with-endpoint\\online-store\\node_modules\\interweave\\src\\Markup.tsx","H:\\Svetik\\qa-testing\\online-store-with-endpoint\\online-store\\node_modules\\interweave\\src\\Interweave.tsx"],"sourcesContent":["import { Filter } from './Filter';\r\nimport { ElementAttributes } from './types';\r\n\r\nconst INVALID_STYLES = /(url|image|image-set)\\(/i;\r\n\r\nexport class StyleFilter extends Filter {\r\n\toverride attribute<K extends keyof ElementAttributes>(\r\n\t\tname: K,\r\n\t\tvalue: ElementAttributes[K],\r\n\t): ElementAttributes[K] {\r\n\t\tif (name === 'style') {\r\n\t\t\tObject.keys(value).forEach((key) => {\r\n\t\t\t\tif (String(value[key]).match(INVALID_STYLES)) {\r\n\t\t\t\t\t// eslint-disable-next-line no-param-reassign\r\n\t\t\t\t\tdelete value[key];\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-return\r\n\t\treturn value;\r\n\t}\r\n}\r\n","/* eslint-disable no-bitwise, no-cond-assign, complexity, @typescript-eslint/no-unsafe-return */\r\n\r\nimport React from 'react';\r\nimport escapeHtml from 'escape-html';\r\nimport {\r\n\tALLOWED_TAG_LIST,\r\n\tATTRIBUTES,\r\n\tATTRIBUTES_TO_PROPS,\r\n\tBANNED_TAG_LIST,\r\n\tFILTER_CAST_BOOL,\r\n\tFILTER_CAST_NUMBER,\r\n\tFILTER_DENY,\r\n\tFILTER_NO_CAST,\r\n\tTAGS,\r\n} from './constants';\r\nimport { Element } from './Element';\r\nimport { StyleFilter } from './StyleFilter';\r\nimport {\r\n\tAttributes,\r\n\tAttributeValue,\r\n\tChildrenNode,\r\n\tElementAttributes,\r\n\tElementProps,\r\n\tFilterInterface,\r\n\tMatcherElementsMap,\r\n\tMatcherInterface,\r\n\tNode,\r\n\tNodeConfig,\r\n\tParserProps,\r\n} from './types';\r\n\r\nconst ELEMENT_NODE = 1;\r\nconst TEXT_NODE = 3;\r\nconst INVALID_ROOTS = /^<(!doctype|(html|head|body)(\\s|>))/i;\r\nconst ALLOWED_ATTRS = /^(aria-|data-|\\w+:)/iu;\r\nconst OPEN_TOKEN = /{{{(\\w+)\\/?}}}/;\r\n\r\nfunction createDocument() {\r\n\t// Maybe SSR? Just do nothing instead of crashing!\r\n\tif (typeof window === 'undefined' || typeof document === 'undefined') {\r\n\t\treturn undefined;\r\n\t}\r\n\r\n\treturn document.implementation.createHTMLDocument('Interweave');\r\n}\r\n\r\nexport class Parser {\r\n\tallowed: Set<string>;\r\n\r\n\tbanned: Set<string>;\r\n\r\n\tblocked: Set<string>;\r\n\r\n\tcontainer?: HTMLElement;\r\n\r\n\tcontent: Node[] = [];\r\n\r\n\tprops: ParserProps;\r\n\r\n\tmatchers: MatcherInterface[];\r\n\r\n\tfilters: FilterInterface[];\r\n\r\n\tkeyIndex: number;\r\n\r\n\tconstructor(\r\n\t\tmarkup: string,\r\n\t\tprops: ParserProps = {},\r\n\t\tmatchers: MatcherInterface[] = [],\r\n\t\tfilters: FilterInterface[] = [],\r\n\t) {\r\n\t\tif (__DEV__ && markup && typeof markup !== 'string') {\r\n\t\t\tthrow new TypeError('Interweave parser requires a valid string.');\r\n\t\t}\r\n\r\n\t\tthis.props = props;\r\n\t\tthis.matchers = matchers;\r\n\t\tthis.filters = [...filters, new StyleFilter()];\r\n\t\tthis.keyIndex = -1;\r\n\t\tthis.container = this.createContainer(markup || '');\r\n\t\tthis.allowed = new Set(props.allowList ?? ALLOWED_TAG_LIST);\r\n\t\tthis.banned = new Set(BANNED_TAG_LIST);\r\n\t\tthis.blocked = new Set(props.blockList);\r\n\t}\r\n\r\n\t/**\r\n\t * Loop through and apply all registered attribute filters.\r\n\t */\r\n\tapplyAttributeFilters<K extends keyof ElementAttributes>(\r\n\t\tname: K,\r\n\t\tvalue: ElementAttributes[K],\r\n\t): ElementAttributes[K] {\r\n\t\treturn this.filters.reduce(\r\n\t\t\t(nextValue, filter) =>\r\n\t\t\t\tnextValue !== null && typeof filter.attribute === 'function'\r\n\t\t\t\t\t? filter.attribute(name, nextValue)\r\n\t\t\t\t\t: nextValue,\r\n\t\t\tvalue,\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Loop through and apply all registered node filters.\r\n\t */\r\n\tapplyNodeFilters(name: string, node: HTMLElement | null): HTMLElement | null {\r\n\t\t// Allow null to be returned\r\n\t\treturn this.filters.reduce(\r\n\t\t\t(nextNode, filter) =>\r\n\t\t\t\tnextNode !== null && typeof filter.node === 'function'\r\n\t\t\t\t\t? filter.node(name, nextNode)\r\n\t\t\t\t\t: nextNode,\r\n\t\t\tnode,\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Loop through and apply all registered matchers to the string.\r\n\t * If a match is found, create a React element, and build a new array.\r\n\t * This array allows React to interpolate and render accordingly.\r\n\t */\r\n\tapplyMatchers(string: string, parentConfig: NodeConfig): ChildrenNode {\r\n\t\tconst elements: MatcherElementsMap = {};\r\n\t\tconst { props } = this;\r\n\t\tlet matchedString = string;\r\n\t\tlet elementIndex = 0;\r\n\t\tlet parts = null;\r\n\r\n\t\tthis.matchers.forEach((matcher) => {\r\n\t\t\tconst tagName = matcher.asTag().toLowerCase();\r\n\t\t\tconst config = this.getTagConfig(tagName);\r\n\r\n\t\t\t// Skip matchers that have been disabled from props or are not supported\r\n\t\t\tif ((props as Record<string, unknown>)[matcher.inverseName] || !this.isTagAllowed(tagName)) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Skip matchers in which the child cannot be rendered\r\n\t\t\tif (!this.canRenderChild(parentConfig, config)) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Continuously trigger the matcher until no matches are found\r\n\t\t\tlet tokenizedString = '';\r\n\r\n\t\t\twhile (matchedString && (parts = matcher.match(matchedString))) {\r\n\t\t\t\tconst { index, length, match, valid, void: isVoid, ...partProps } = parts;\r\n\t\t\t\tconst tokenName = matcher.propName + String(elementIndex);\r\n\r\n\t\t\t\t// Piece together a new string with interpolated tokens\r\n\t\t\t\tif (index > 0) {\r\n\t\t\t\t\ttokenizedString += matchedString.slice(0, index);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (valid) {\r\n\t\t\t\t\ttokenizedString += isVoid\r\n\t\t\t\t\t\t? `{{{${tokenName}/}}}`\r\n\t\t\t\t\t\t: `{{{${tokenName}}}}${match}{{{/${tokenName}}}}`;\r\n\r\n\t\t\t\t\tthis.keyIndex += 1;\r\n\r\n\t\t\t\t\telementIndex += 1;\r\n\t\t\t\t\telements[tokenName] = {\r\n\t\t\t\t\t\tchildren: match,\r\n\t\t\t\t\t\tmatcher,\r\n\t\t\t\t\t\tprops: {\r\n\t\t\t\t\t\t\t...props,\r\n\t\t\t\t\t\t\t...partProps,\r\n\t\t\t\t\t\t\tkey: this.keyIndex,\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t};\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttokenizedString += match;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Reduce the string being matched against,\r\n\t\t\t\t// otherwise we end up in an infinite loop!\r\n\t\t\t\tif (matcher.greedy) {\r\n\t\t\t\t\tmatchedString = tokenizedString + matchedString.slice(index + length);\r\n\t\t\t\t\ttokenizedString = '';\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// eslint-disable-next-line unicorn/explicit-length-check\r\n\t\t\t\t\tmatchedString = matchedString.slice(index + (length || match.length));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Update the matched string with the tokenized string,\r\n\t\t\t// so that the next matcher can apply to it.\r\n\t\t\tif (!matcher.greedy) {\r\n\t\t\t\tmatchedString = tokenizedString + matchedString;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tif (elementIndex === 0) {\r\n\t\t\treturn string;\r\n\t\t}\r\n\r\n\t\treturn this.replaceTokens(matchedString, elements);\r\n\t}\r\n\r\n\t/**\r\n\t * Determine whether the child can be rendered within the parent.\r\n\t */\r\n\tcanRenderChild(parentConfig: NodeConfig, childConfig: NodeConfig): boolean {\r\n\t\tif (!parentConfig.tagName || !childConfig.tagName) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// No children\r\n\t\tif (parentConfig.void) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// Valid children\r\n\t\tif (parentConfig.children.length > 0) {\r\n\t\t\treturn parentConfig.children.includes(childConfig.tagName);\r\n\t\t}\r\n\r\n\t\tif (parentConfig.invalid.length > 0 && parentConfig.invalid.includes(childConfig.tagName)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// Valid parent\r\n\t\tif (childConfig.parent.length > 0) {\r\n\t\t\treturn childConfig.parent.includes(parentConfig.tagName);\r\n\t\t}\r\n\r\n\t\t// Self nesting\r\n\t\tif (!parentConfig.self && parentConfig.tagName === childConfig.tagName) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// Content category type\r\n\t\treturn Boolean(parentConfig && parentConfig.content & childConfig.type);\r\n\t}\r\n\r\n\t/**\r\n\t * Convert line breaks in a string to HTML `<br/>` tags.\r\n\t * If the string contains HTML, we should not convert anything,\r\n\t * as line breaks should be handled by `<br/>`s in the markup itself.\r\n\t */\r\n\tconvertLineBreaks(markup: string): string {\r\n\t\tconst { noHtml, disableLineBreaks } = this.props;\r\n\r\n\t\tif (noHtml || disableLineBreaks || markup.match(/<((?:\\/[ a-z]+)|(?:[ a-z]+\\/))>/gi)) {\r\n\t\t\treturn markup;\r\n\t\t}\r\n\r\n\t\t// Replace carriage returns\r\n\t\tlet nextMarkup = markup.replace(/\\r\\n/g, '\\n');\r\n\r\n\t\t// Replace long line feeds\r\n\t\tnextMarkup = nextMarkup.replace(/\\n{3,}/g, '\\n\\n\\n');\r\n\r\n\t\t// Replace line feeds with `<br/>`s\r\n\t\tnextMarkup = nextMarkup.replace(/\\n/g, '<br/>');\r\n\r\n\t\treturn nextMarkup;\r\n\t}\r\n\r\n\t/**\r\n\t * Create a detached HTML document that allows for easy HTML\r\n\t * parsing while not triggering scripts or loading external\r\n\t * resources.\r\n\t */\r\n\tcreateContainer(markup: string): HTMLElement | undefined {\r\n\t\tconst factory =\r\n\t\t\t(typeof global !== 'undefined' && global.INTERWEAVE_SSR_POLYFILL) || createDocument;\r\n\t\tconst doc = factory();\r\n\r\n\t\tif (!doc) {\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\r\n\t\tconst tag = this.props.containerTagName ?? 'body';\r\n\t\tconst el = tag === 'body' || tag === 'fragment' ? doc.body : doc.createElement(tag);\r\n\r\n\t\tif (markup.match(INVALID_ROOTS)) {\r\n\t\t\tif (__DEV__) {\r\n\t\t\t\tthrow new Error('HTML documents as Interweave content are not supported.');\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tel.innerHTML = this.convertLineBreaks(this.props.escapeHtml ? escapeHtml(markup) : markup);\r\n\t\t}\r\n\r\n\t\treturn el;\r\n\t}\r\n\r\n\t/**\r\n\t * Convert an elements attribute map to an object map.\r\n\t * Returns null if no attributes are defined.\r\n\t */\r\n\textractAttributes(node: HTMLElement): Attributes | null {\r\n\t\tconst { allowAttributes } = this.props;\r\n\t\tconst attributes: Attributes = {};\r\n\t\tlet count = 0;\r\n\r\n\t\tif (node.nodeType !== ELEMENT_NODE || !node.attributes) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// @ts-expect-error Cant type iterator\r\n\t\t[...node.attributes].forEach((attr: Attr) => {\r\n\t\t\tconst { name, value } = attr;\r\n\t\t\tconst newName = name.toLowerCase();\r\n\t\t\tconst filter = ATTRIBUTES[newName] || ATTRIBUTES[name];\r\n\r\n\t\t\t// Verify the node is safe from attacks\r\n\t\t\tif (!this.isSafe(node)) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Do not allow denied attributes, excluding ARIA attributes\r\n\t\t\t// Do not allow events or XSS injections\r\n\t\t\tif (\r\n\t\t\t\t!newName.match(ALLOWED_ATTRS) &&\r\n\t\t\t\t((!allowAttributes && (!filter || filter === FILTER_DENY)) ||\r\n\t\t\t\t\tnewName.startsWith('on') ||\r\n\t\t\t\t\tvalue.replace(/(\\s|\\0|&#x0([9AD]);)/, '').match(/(javascript|vbscript|livescript|xss):/i))\r\n\t\t\t) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Apply attribute filters\r\n\t\t\tlet newValue: AttributeValue = newName === 'style' ? this.extractStyleAttribute(node) : value;\r\n\r\n\t\t\t// Cast to boolean\r\n\t\t\tif (filter === FILTER_CAST_BOOL) {\r\n\t\t\t\tnewValue = true;\r\n\r\n\t\t\t\t// Cast to number\r\n\t\t\t} else if (filter === FILTER_CAST_NUMBER) {\r\n\t\t\t\tnewValue = Number.parseFloat(String(newValue));\r\n\r\n\t\t\t\t// Cast to string\r\n\t\t\t} else if (filter !== FILTER_NO_CAST) {\r\n\t\t\t\tnewValue = String(newValue);\r\n\t\t\t}\r\n\r\n\t\t\tattributes[ATTRIBUTES_TO_PROPS[newName] || newName] = this.applyAttributeFilters(\r\n\t\t\t\tnewName as keyof ElementAttributes,\r\n\t\t\t\tnewValue,\r\n\t\t\t) as AttributeValue;\r\n\t\t\tcount += 1;\r\n\t\t});\r\n\r\n\t\tif (count === 0) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn attributes;\r\n\t}\r\n\r\n\t/**\r\n\t * Extract the style attribute as an object and remove values that allow for attack vectors.\r\n\t */\r\n\textractStyleAttribute(node: HTMLElement): object {\r\n\t\tconst styles: Record<string, number | string> = {};\r\n\r\n\t\t// eslint-disable-next-line unicorn/prefer-spread\r\n\t\tArray.from(node.style).forEach((key) => {\r\n\t\t\tconst value = node.style[key as keyof CSSStyleDeclaration];\r\n\r\n\t\t\tif (typeof value === 'string' || typeof value === 'number') {\r\n\t\t\t\tstyles[key.replace(/-([a-z])/g, (match, letter) => String(letter).toUpperCase())] = value;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn styles;\r\n\t}\r\n\r\n\t/**\r\n\t * Return configuration for a specific tag.\r\n\t */\r\n\tgetTagConfig(tagName: string): NodeConfig {\r\n\t\tconst common = {\r\n\t\t\tchildren: [],\r\n\t\t\tcontent: 0,\r\n\t\t\tinvalid: [],\r\n\t\t\tparent: [],\r\n\t\t\tself: true,\r\n\t\t\ttagName: '',\r\n\t\t\ttype: 0,\r\n\t\t\tvoid: false,\r\n\t\t};\r\n\r\n\t\t// Only spread when a tag config exists,\r\n\t\t// otherwise we use the empty `tagName`\r\n\t\t// for parent config inheritance.\r\n\t\tif (TAGS[tagName]) {\r\n\t\t\treturn {\r\n\t\t\t\t...common,\r\n\t\t\t\t...TAGS[tagName],\r\n\t\t\t\ttagName,\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\treturn common;\r\n\t}\r\n\r\n\t/**\r\n\t * Verify that a node is safe from XSS and injection attacks.\r\n\t */\r\n\tisSafe(node: HTMLElement): boolean {\r\n\t\t// URLs should only support HTTP, email and phone numbers\r\n\t\tif (typeof HTMLAnchorElement !== 'undefined' && node instanceof HTMLAnchorElement) {\r\n\t\t\tconst href = node.getAttribute('href');\r\n\r\n\t\t\t// Fragment protocols start with about:\r\n\t\t\t// So let's just allow them\r\n\t\t\tif (href?.startsWith('#')) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\tconst protocol = node.protocol.toLowerCase();\r\n\r\n\t\t\treturn (\r\n\t\t\t\tprotocol === ':' ||\r\n\t\t\t\tprotocol === 'http:' ||\r\n\t\t\t\tprotocol === 'https:' ||\r\n\t\t\t\tprotocol === 'mailto:' ||\r\n\t\t\t\tprotocol === 'tel:'\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Verify that an HTML tag is allowed to render.\r\n\t */\r\n\tisTagAllowed(tagName: string): boolean {\r\n\t\tif (this.banned.has(tagName) || this.blocked.has(tagName)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\r\n\t\treturn this.props.allowElements || this.allowed.has(tagName);\r\n\t}\r\n\r\n\t/**\r\n\t * Parse the markup by injecting it into a detached document,\r\n\t * while looping over all child nodes and generating an\r\n\t * array to interpolate into JSX.\r\n\t */\r\n\tparse(): Node[] {\r\n\t\tif (!this.container) {\r\n\t\t\treturn [];\r\n\t\t}\r\n\r\n\t\treturn this.parseNode(this.container, this.getTagConfig(this.container.nodeName.toLowerCase()));\r\n\t}\r\n\r\n\t/**\r\n\t * Loop over the nodes children and generate a\r\n\t * list of text nodes and React elements.\r\n\t */\r\n\tparseNode(parentNode: HTMLElement, parentConfig: NodeConfig): Node[] {\r\n\t\tconst {\r\n\t\t\tnoHtml,\r\n\t\t\tnoHtmlExceptMatchers,\r\n\t\t\tallowElements,\r\n\t\t\ttransform,\r\n\t\t\ttransformOnlyAllowList,\r\n\t\t} = this.props;\r\n\t\tlet content: Node[] = [];\r\n\t\tlet mergedText = '';\r\n\r\n\t\t// @ts-expect-error Cant type iterator\r\n\t\t[...parentNode.childNodes].forEach((node: ChildNode) => {\r\n\t\t\t// Create React elements from HTML elements\r\n\t\t\tif (node.nodeType === ELEMENT_NODE) {\r\n\t\t\t\tconst tagName = node.nodeName.toLowerCase();\r\n\t\t\t\tconst config = this.getTagConfig(tagName);\r\n\r\n\t\t\t\t// Persist any previous text\r\n\t\t\t\tif (mergedText) {\r\n\t\t\t\t\tcontent.push(mergedText);\r\n\t\t\t\t\tmergedText = '';\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Apply node filters first\r\n\t\t\t\tconst nextNode = this.applyNodeFilters(tagName, node as HTMLElement);\r\n\r\n\t\t\t\tif (!nextNode) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Apply transformation second\r\n\t\t\t\tlet children;\r\n\r\n\t\t\t\tif (transform && !(transformOnlyAllowList && !this.isTagAllowed(tagName))) {\r\n\t\t\t\t\tthis.keyIndex += 1;\r\n\t\t\t\t\tconst key = this.keyIndex;\r\n\r\n\t\t\t\t\t// Must occur after key is set\r\n\t\t\t\t\tchildren = this.parseNode(nextNode, config);\r\n\r\n\t\t\t\t\tconst transformed = transform(nextNode, children, config);\r\n\r\n\t\t\t\t\tif (transformed === null) {\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (typeof transformed !== 'undefined') {\r\n\t\t\t\t\t\tcontent.push(React.cloneElement(transformed as React.ReactElement<unknown>, { key }));\r\n\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Reset as we're not using the transformation\r\n\t\t\t\t\tthis.keyIndex = key - 1;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Never allow these tags (except via a transformer)\r\n\t\t\t\tif (this.banned.has(tagName)) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Only render when the following criteria is met:\r\n\t\t\t\t//  - HTML has not been disabled\r\n\t\t\t\t//  - Tag is allowed\r\n\t\t\t\t//  - Child is valid within the parent\r\n\t\t\t\tif (\r\n\t\t\t\t\t!(noHtml || (noHtmlExceptMatchers && tagName !== 'br')) &&\r\n\t\t\t\t\tthis.isTagAllowed(tagName) &&\r\n\t\t\t\t\t(allowElements || this.canRenderChild(parentConfig, config))\r\n\t\t\t\t) {\r\n\t\t\t\t\tthis.keyIndex += 1;\r\n\r\n\t\t\t\t\t// Build the props as it makes it easier to test\r\n\t\t\t\t\tconst attributes = this.extractAttributes(nextNode);\r\n\t\t\t\t\tconst elementProps: ElementProps = {\r\n\t\t\t\t\t\ttagName,\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tif (attributes) {\r\n\t\t\t\t\t\telementProps.attributes = attributes;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (config.void) {\r\n\t\t\t\t\t\telementProps.selfClose = config.void;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcontent.push(\r\n\t\t\t\t\t\tReact.createElement(\r\n\t\t\t\t\t\t\tElement,\r\n\t\t\t\t\t\t\t{ ...elementProps, key: this.keyIndex },\r\n\t\t\t\t\t\t\tchildren ?? this.parseNode(nextNode, config),\r\n\t\t\t\t\t\t),\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\t// Render the children of the current element only.\r\n\t\t\t\t\t// Important: If the current element is not allowed,\r\n\t\t\t\t\t// use the parent element for the next scope.\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcontent = [\r\n\t\t\t\t\t\t...content,\r\n\t\t\t\t\t\t...this.parseNode(nextNode, config.tagName ? config : parentConfig),\r\n\t\t\t\t\t];\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Apply matchers if a text node\r\n\t\t\t} else if (node.nodeType === TEXT_NODE) {\r\n\t\t\t\tconst text =\r\n\t\t\t\t\tnoHtml && !noHtmlExceptMatchers\r\n\t\t\t\t\t\t? node.textContent\r\n\t\t\t\t\t\t: // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\r\n\t\t\t\t\t\t  this.applyMatchers(node.textContent || '', parentConfig);\r\n\r\n\t\t\t\tif (Array.isArray(text)) {\r\n\t\t\t\t\tcontent = [...content, ...text];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tmergedText += text!;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tif (mergedText) {\r\n\t\t\tcontent.push(mergedText);\r\n\t\t}\r\n\r\n\t\treturn content;\r\n\t}\r\n\r\n\t/**\r\n\t * Deconstruct the string into an array, by replacing custom tokens with React elements,\r\n\t * so that React can render it correctly.\r\n\t */\r\n\treplaceTokens(tokenizedString: string, elements: MatcherElementsMap): ChildrenNode {\r\n\t\tif (!tokenizedString.includes('{{{')) {\r\n\t\t\treturn tokenizedString;\r\n\t\t}\r\n\r\n\t\tconst nodes: Node[] = [];\r\n\t\tlet text = tokenizedString;\r\n\t\tlet open: RegExpMatchArray | null = null;\r\n\r\n\t\t// Find an open token tag\r\n\t\twhile ((open = text.match(OPEN_TOKEN))) {\r\n\t\t\tconst [match, tokenName] = open;\r\n\t\t\tconst startIndex = open.index!;\r\n\t\t\tconst isVoid = match.includes('/');\r\n\r\n\t\t\tif (__DEV__ && !elements[tokenName]) {\r\n\t\t\t\tthrow new Error(`Token \"${tokenName}\" found but no matching element to replace with.`);\r\n\t\t\t}\r\n\r\n\t\t\t// Extract the previous non-token text\r\n\t\t\tif (startIndex > 0) {\r\n\t\t\t\tnodes.push(text.slice(0, startIndex));\r\n\r\n\t\t\t\t// Reduce text so that the closing tag will be found after the opening\r\n\t\t\t\ttext = text.slice(startIndex);\r\n\t\t\t}\r\n\r\n\t\t\tconst { children, matcher, props: elementProps } = elements[tokenName];\r\n\t\t\tlet endIndex: number;\r\n\r\n\t\t\t// Use tag as-is if void\r\n\t\t\tif (isVoid) {\r\n\t\t\t\tendIndex = match.length;\r\n\r\n\t\t\t\tnodes.push(matcher.createElement(children, elementProps));\r\n\r\n\t\t\t\t// Find the closing tag if not void\r\n\t\t\t} else {\r\n\t\t\t\tconst close = text.match(new RegExp(`{{{/${tokenName}}}}`))!;\r\n\r\n\t\t\t\tif (__DEV__ && !close) {\r\n\t\t\t\t\tthrow new Error(`Closing token missing for interpolated element \"${tokenName}\".`);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tendIndex = close.index! + close[0].length;\r\n\r\n\t\t\t\tnodes.push(\r\n\t\t\t\t\tmatcher.createElement(\r\n\t\t\t\t\t\tthis.replaceTokens(text.slice(match.length, close.index), elements),\r\n\t\t\t\t\t\telementProps,\r\n\t\t\t\t\t),\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\t// Reduce text for the next interation\r\n\t\t\ttext = text.slice(endIndex);\r\n\t\t}\r\n\r\n\t\t// Extra the remaining text\r\n\t\tif (text.length > 0) {\r\n\t\t\tnodes.push(text);\r\n\t\t}\r\n\r\n\t\t// Reduce to a string if possible\r\n\t\tif (nodes.length === 0) {\r\n\t\t\treturn '';\r\n\t\t}\r\n\t\tif (nodes.length === 1 && typeof nodes[0] === 'string') {\r\n\t\t\treturn nodes[0];\r\n\t\t}\r\n\r\n\t\treturn nodes;\r\n\t}\r\n}\r\n","/* eslint-disable react/jsx-fragments */\r\n\r\nimport React from 'react';\r\nimport { Element } from './Element';\r\nimport { Parser } from './Parser';\r\nimport { MarkupProps } from './types';\r\n\r\nexport function Markup(props: MarkupProps) {\r\n\tconst {\r\n\t\tattributes,\r\n\t\tclassName,\r\n\t\tcontainerTagName,\r\n\t\tcontent,\r\n\t\temptyContent,\r\n\t\tparsedContent,\r\n\t\ttagName,\r\n\t\tnoWrap: baseNoWrap,\r\n\t} = props;\r\n\tconst tag = containerTagName ?? tagName ?? 'span';\r\n\tconst noWrap = tag === 'fragment' ? true : baseNoWrap;\r\n\tlet mainContent;\r\n\r\n\tif (parsedContent) {\r\n\t\tmainContent = parsedContent;\r\n\t} else {\r\n\t\tconst markup = new Parser(content ?? '', props).parse();\r\n\r\n\t\tif (markup.length > 0) {\r\n\t\t\tmainContent = markup;\r\n\t\t}\r\n\t}\r\n\r\n\tif (!mainContent) {\r\n\t\tmainContent = emptyContent;\r\n\t}\r\n\r\n\tif (noWrap) {\r\n\t\t// eslint-disable-next-line react/jsx-no-useless-fragment\r\n\t\treturn <React.Fragment>{mainContent}</React.Fragment>;\r\n\t}\r\n\r\n\treturn (\r\n\t\t<Element attributes={attributes} className={className} tagName={tag}>\r\n\t\t\t{mainContent}\r\n\t\t</Element>\r\n\t);\r\n}\r\n","/* eslint-disable promise/prefer-await-to-callbacks */\r\nimport React from 'react';\r\nimport { Markup } from './Markup';\r\nimport { Parser } from './Parser';\r\nimport { InterweaveProps } from './types';\r\n\r\nexport function Interweave(props: InterweaveProps) {\r\n\tconst {\r\n\t\tattributes,\r\n\t\tclassName,\r\n\t\tcontent = '',\r\n\t\tdisableFilters = false,\r\n\t\tdisableMatchers = false,\r\n\t\temptyContent = null,\r\n\t\tfilters = [],\r\n\t\tmatchers = [],\r\n\t\tonAfterParse = null,\r\n\t\tonBeforeParse = null,\r\n\t\ttagName = 'span',\r\n\t\tnoWrap = false,\r\n\t\t...parserProps\r\n\t} = props;\r\n\tconst allMatchers = disableMatchers ? [] : matchers;\r\n\tconst allFilters = disableFilters ? [] : filters;\r\n\tconst beforeCallbacks = onBeforeParse ? [onBeforeParse] : [];\r\n\tconst afterCallbacks = onAfterParse ? [onAfterParse] : [];\r\n\r\n\t// Inherit callbacks from matchers\r\n\tallMatchers.forEach((matcher) => {\r\n\t\tif (matcher.onBeforeParse) {\r\n\t\t\tbeforeCallbacks.push(matcher.onBeforeParse.bind(matcher));\r\n\t\t}\r\n\r\n\t\tif (matcher.onAfterParse) {\r\n\t\t\tafterCallbacks.push(matcher.onAfterParse.bind(matcher));\r\n\t\t}\r\n\t});\r\n\r\n\t// Trigger before callbacks\r\n\tconst markup = beforeCallbacks.reduce((string, callback) => {\r\n\t\tconst nextString = callback(string, props);\r\n\r\n\t\tif (__DEV__ && typeof nextString !== 'string') {\r\n\t\t\tthrow new TypeError('Interweave `onBeforeParse` must return a valid HTML string.');\r\n\t\t}\r\n\r\n\t\treturn nextString;\r\n\t}, content ?? '');\r\n\r\n\t// Parse the markup\r\n\tconst parser = new Parser(markup, parserProps, allMatchers, allFilters);\r\n\r\n\t// Trigger after callbacks\r\n\tconst nodes = afterCallbacks.reduce((parserNodes, callback) => {\r\n\t\tconst nextNodes = callback(parserNodes, props);\r\n\r\n\t\tif (__DEV__ && !Array.isArray(nextNodes)) {\r\n\t\t\tthrow new TypeError(\r\n\t\t\t\t'Interweave `onAfterParse` must return an array of strings and React elements.',\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\treturn nextNodes;\r\n\t}, parser.parse());\r\n\r\n\treturn (\r\n\t\t<Markup\r\n\t\t\tattributes={attributes}\r\n\t\t\tclassName={className}\r\n\t\t\t// eslint-disable-next-line react/destructuring-assignment\r\n\t\t\tcontainerTagName={props.containerTagName}\r\n\t\t\temptyContent={emptyContent}\r\n\t\t\tnoWrap={noWrap}\r\n\t\t\tparsedContent={nodes.length === 0 ? undefined : nodes}\r\n\t\t\ttagName={tagName}\r\n\t\t/>\r\n\t);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}